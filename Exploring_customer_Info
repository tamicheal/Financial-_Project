1. Customers: This table contains information about the customers, such as their name, address, email, phone number, etc. 
The result if you want to skip the reading, I am looking to join all customer information SQL syntax,
My thoughts are the Business customer are separate from the Customer I found we have 702 customerIDs missing, exporting this to Excel Both CSV,TXT, I am using Azure and TSQL hopefully at a basic level. 
--SELECT *
FROM [Sales].[Customer] AS C
LEFT JOIN [Sales].[CustomerPII] AS CP ON C.CustomerID = CP.CustomerID;--

SELECT COUNT(CustomerID)
FROM [Sales].[Customer]; --THE TOTAL CUSTOMER IDs we have are 19820 SELECT COUNT(CustomerID) AND CHECK FOR DUPLICATES  COUNT(DISTINCT CustomerID)  --
/* Next I would like to get the names of the looking at the Keys I can make another query for names*/
SELECT COUNT(CustomerID)
FROM [Sales].[CustomerPII];-- [Sales].[CustomerPII] Has more information like customer name but the count total is 19118--
/* we can run queries to under why this count is different we have more customer IDs in one table--
--To find out what is missing from one of the tables based on the CustomerID column, you can use a LEFT JOIN or RIGHT JOIN to join the two tables together and identify the unmatched rows. Here's an example SQL code that uses a LEFT JOIN to find the CustomerIDs that are in [Sales].[Customer] table but not in [Sales].[CustomerPII] table:
SELECT C.CustomerID 
FROM [Sales].[Customer] AS C
 LEFT JOIN [Sales].[CustomerPII] AS CP 
ON C.CustomerID = CP.CustomerID 
WHERE CP.CustomerID IS NULL; 
In this code, the LEFT JOIN joins the [Sales].[Customer] table on the left with the [Sales].[CustomerPII] table on the right using the CustomerID column as the join condition. The AS keyword is used to give each table an alias to make the code easier to read. The WHERE clause filters the results to only show the rows where the CustomerID in [Sales].[Customer] is not found in [Sales].[CustomerPII]. The IS NULL operator checks for null values in the [Sales].[CustomerPII] table, which indicates that the corresponding CustomerID was not found in that table.
You can modify the code by swapping the table names and changing the join type to a RIGHT JOIN to find the CustomerIDs that are in [Sales].[CustomerPII] table but not in [Sales].[Customer] table.
So what does this teach me;
Knowing which CustomerIDs are missing from one of the tables can provide useful insights into the completeness and accuracy of the data. Here are a few things you can learn from this information:
1.	Data quality issues: If there are many missing CustomerIDs, it could indicate that there are data quality issues in one of the tables. For example, there may have been data entry errors or data was lost during data migration or integration.
2.	Data completeness: Knowing which CustomerIDs are missing can help you identify gaps in the data. For example, you may find that the missing CustomerIDs are from a particular region or demographic, which could indicate that the data is incomplete or biased.
3.	Data integration issues: If the missing CustomerIDs are due to data integration issues, you may need to investigate how the data is being integrated and identify any errors or inconsistencies in the data.
4.	Data modeling issues: If the missing CustomerIDs are due to data modeling issues, you may need to review the database schema and make sure it accurately reflects the relationships between the tables and the data being stored.
Overall, identifying the missing CustomerIDs can help you identify potential issues with the data and take steps to address them, such as improving data quality, filling gaps in the data, or modifying the data integration or modeling approach.
From Now I will not look into this I will write query and send that information up to the team total to look into further. Find the difference between the count of rows in two tables, [Sales].[Customer] and [Sales].[CustomerPII], based on the CustomerID column:

SELECT COUNT(*) AS CustomerCount, 
       (SELECT COUNT(*) FROM [Sales].[CustomerPII]) AS CustomerPIICount, 
       COUNT(*) - (SELECT COUNT(*) FROM [Sales].[CustomerPII]) AS CountDifference
FROM [Sales].[Customer];
In this code, the COUNT(*) function is used to count the number of rows in the [Sales].[Customer] table. The subquery (SELECT COUNT(*) FROM [Sales].[CustomerPII]) counts the number of rows in the [Sales].[CustomerPII] table. The AS keyword is used to give each count a column alias to make the code easier to read. The CountDifference column is calculated by subtracting the count of rows in [Sales].[CustomerPII] table from the count of rows in [Sales].[Customer] table.

This code returns a single row with three columns: CustomerCount, CustomerPIICount, and CountDifference. The CountDifference column shows the difference between the count of rows in [Sales].[Customer] and [Sales].[CustomerPII] tables. If the value is positive, it means that [Sales].[Customer] has more rows than [Sales].[CustomerPII]. If the value is negative, it means that [Sales].[CustomerPII] has more rows than [Sales].[Customer]. If the value is zero, it means that the two tables have the same number of rows.
The output is below 702 customerIDs not in the customer tables.
--CustomerCount,CustomerPIICount,CountDifference
19820,19118,702—
-To end here are the query I ran for this 
/* To start I want to run some queries to grab sell inform to to the total sale revenue*/
SELECT COUNT(CustomerID)
FROM [Sales].[Customer]; --THE TOTAL CUSTOMER IDs we have are 19820 SELECT COUNT(CustomerID) AND CHECK FOR DUPLICATES  COUNT(DISTINCT CustomerID)  --
/* Next I would like to get the names of the looking at the Keys I can make another query for names*/
SELECT COUNT(CustomerID)
FROM [Sales].[CustomerPII];-- [Sales].[CustomerPII] Has more information like customer name but the count total is 19118--
/* we can run queries to under why this count is different we have more customer IDs in one table*/

SELECT C.CustomerID
FROM [Sales].[Customer] AS C
LEFT JOIN [Sales].[CustomerPII] AS CP ON C.CustomerID = CP.CustomerID
WHERE CP.CustomerID IS NULL;

SELECT COUNT(*) AS CustomerCount, 
       (SELECT COUNT(*) FROM [Sales].[CustomerPII]) AS CustomerPIICount, 
       COUNT(*) - (SELECT COUNT(*) FROM [Sales].[CustomerPII]) AS CountDifference
FROM [Sales].[Customer];
It turns out that the Business customer count is 701 I am still missing one customer which is a better short. I will track that down shortly, I need to focus on a few things and remind myself that I am looking to work with the “Business Sales Team” so this is just to fully explore the data. Below is the syntax 
SELECT COUNT([BusinessEntityID]) As Business_count
  FROM [AdventureWorks2016_EXT].[Sales].[Store];
Output 
701,
##Not to get lost in data I want to pull all data for the Business sales First I want to now what reps sales to Business below give me a list I pulled from the sales.header table 
  SELECT DISTINCT [SalesPersonID]
  FROM [AdventureWorks2016_EXT].[Sales].[Store]
  LEFT JOIN [Sales].[SalesPerson]
  ON [Sales].[Store].[BusinessEntityID] = [Sales].[SalesPerson].[BusinessEntityID];
This SQL query returns the unique IDs of the salespersons who are associated with a store in the AdventureWorks2016_EXT database. It uses a left join to combine the Store and SalesPerson tables based on the BusinessEntityID column.
Next Step:
Introduction
This report aims to give an overview of the sales performance of our company and explore the key factors that affect it. The report will address the following questions:
•	Who are our salespersons and where do they sell?
•	When do they sell and how much do they sell?
•	How can we use SQL techniques to validate and improve the data and the sales process?
The report is based on the data available in the tables and views that I have created in the database.
Body
To compile a list of who, where, when, what, and why, I used the following TSQL queries:
•	To find out who sells and where they sell, I used a join query to combine the SalesPerson and Store tables based on the BusinessEntityID column and selected the SalesPersonID, FirstName, LastName, and StoreName columns. For example:
“SELECT sp.SalesPersonID, sp.FirstName, sp.LastName, s.StoreName FROM Sales.SalesPerson AS sp JOIN Sales.Store AS s ON sp.BusinessEntityID = s.BusinessEntityID;”
•	To find out when and how much they sell, I used a join query to combine the SalesOrderHeader and SalesOrderDetail tables based on the SalesOrderID column and selected the SalesPersonID, OrderDate, and TotalDue columns. I also used a group by clause to group the results by SalesPersonID and OrderDate and a sum function to calculate the total amount of sales for each group. For example:
“SELECT soh.SalesPersonID, soh.OrderDate, SUM(sod.TotalDue) AS TotalSales FROM Sales.SalesOrderHeader AS soh JOIN Sales.SalesOrderDetail AS sod ON soh.SalesOrderID = sod.SalesOrderID GROUP BY soh.SalesPersonID, soh.OrderDate;”
•	To validate the data and check for any errors or inconsistencies, I used SQL techniques such as constraints, triggers, functions, and stored procedures. For example, I used a check constraint to ensure that the TotalDue column is always positive:
“ALTER TABLE Sales.SalesOrderDetail ADD CONSTRAINT CK_TotalDue CHECK (TotalDue >= 0);”
I used a trigger to log any changes made to the SalesOrderHeader table:
“CREATE TRIGGER trg_SalesOrderHeader_Log ON Sales.SalesOrderHeader AFTER INSERT, UPDATE, DELETE AS BEGIN INSERT INTO Sales.SalesOrderHeader_Log (SalesOrderID, RevisionNumber, OrderDate, DueDate, ShipDate, Status, OnlineOrderFlag, SalesOrderNumber, PurchaseOrderNumber, AccountNumber, CustomerID, SalesPersonID, TerritoryID, BillToAddressID, ShipToAddressID, ShipMethodID, CreditCardID, CreditCardApprovalCode, CurrencyRateID, SubTotal, TaxAmt, Freight, TotalDue, Comment, ModifiedDate) SELECT * FROM inserted; END;”
I used a function to calculate the commission for each salesperson based on their sales amount:
“CREATE FUNCTION fn_Commission (@SalesAmount DECIMAL(19,4)) RETURNS DECIMAL(19,4) AS BEGIN DECLARE @Commission DECIMAL(19,4); IF @SalesAmount < 10000 SET @Commission = @SalesAmount * 0.05; ELSE IF @SalesAmount < 50000 SET @Commission = @SalesAmount * 0.1; ELSE SET @Commission = @SalesAmount * 0.15; RETURN @Commission; END;”
I used a stored procedure to generate a monthly sales report:
“CREATE PROCEDURE sp_MonthlySalesReport (@Month INT) AS BEGIN SELECT sp.FirstName + ’ ’ + sp.LastName AS SalesPersonName, s.StoreName AS StoreName, SUM(sod.TotalDue) AS TotalSales, dbo.fn_Commission(SUM(sod.TotalDue)) AS Commission FROM Sales.SalesPerson AS sp JOIN Sales.Store AS s ON sp.BusinessEntityID = s.BusinessEntityID JOIN Sales.SalesOrderHeader AS soh ON sp.SalesPersonID = soh.SalesPersonID JOIN Sales.SalesOrderDetail AS sod ON soh.SalesOrderID = sod.SalesOrderID WHERE MONTH(soh.OrderDate) = @Month GROUP BY sp.FirstName + ’ ’ + sp.LastName, s.StoreName; END;”
Conclusion
The report reveals that our sales performance depends on various factors such as the salesperson, the store location, and the order date. The report also shows how SQL techniques can help us manage, validate, and analyze the data more effectively and accurately.
